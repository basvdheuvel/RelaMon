module compile::Mcrl

import grammar::Abstract;
import grammar::Proc;
import grammar::Lmu;
import compile::Proc;
import compile::Utils;
import List;
import String;

str globalTypeToMcrl(GT gt) {
    list[str] parts = globalTypeParts(gt);

    str res = "% Do not forget to declare your custom sorts.";
    for (part <- parts) {
        res = "<res>\n\n<globalTypePartToMcrl(gt, part)>";
    }
    
    Af gacts = globalTypeGacts(gt);
    
    str partProcs = "P_<parts[0]>";
    for (int i <- [1 .. size(parts)]) {
        partProcs = "<partProcs> || P_<parts[i]>";
    }
    
    list[str] blockedActsList = [];
    for (part <- parts) {
        blockedActsList = blockedActsList + afToActDef(false, globalTypeActs(part, gt));
    }
    str blockedActs = joinStrs(", ", blockedActsList);
    
    res = "<res>\n\n% Global implementation.\n\nact <joinStrs("; ", afToActDef(gacts))>;\n\nproc G = block({<blockedActs>}, comm({<joinStrs(", ", globalTypeToCommList(parts, gt))>}, <partProcs>));";
    
    res = "<res>\n\ninit G; % Uncomment this line to test the global implementation.";
    for (part <- parts) {
        res = "<res>\n%init P_<part>; % Uncomment this line to test the implementation for <part>.";
    }
    
    return res;
}

list[str] globalTypeToCommList(GT gt) = globalTypeToCommList(globalTypeParts(gt), gt);
list[str] globalTypeToCommList(list[str] parts, GT gt) = globalTypeToCommList(parts, 1, gt);

list[str] globalTypeToCommList(list[str] parts, int n, message(EXC exc, _, GT cont)) = ["<exc.from>_<n>_out | <exc.to>_<n>_in -\> <exc.from>_<exc.to>_<n>"] + globalTypeToCommList(parts, n+1, cont);
list[str] globalTypeToCommList(list[str] parts, int n, choice(EXC exc, list[CHOICE] choices)) {
    list[str] res = ["<exc.from>_<n>_out_<choice.label> | <exc.to>_<n>_in_<choice.label> -\> <exc.from>_<exc.to>_<n>_<choice.label>" | CHOICE choice <- choices];
    for (int i <- [0 .. size(choices)]) {
        res = res + globalTypeToCommList(parts, n+1+choiceLengthUpTo(i, choices), choices[i].cont);
    }
    return res;
}
list[str] globalTypeToCommList(list[str] parts, int n, end()) = ["<joinStrs(" | ", ["<part>_<n>_end" | str part <- parts])> -\> <joinStrs("_", parts)>_<n>_end"];
list[str] globalTypeToCommList(list[str] parts, int n, recDef(_, GT cont)) = globalTypeToCommList(parts, n, cont);
list[str] globalTypeToCommList(_, _, recCall(_)) = [];

str globalTypePartToMcrl(GT gt, str part) = "% Characteristic process for <part>.\n\n<globalTypeToActDef(part, gt)>\n\n<recProcToMcrl(globalTypeToProc(part, gt), part)>";

str globalTypeToActDef(str part, GT gt) = "act <joinStrs("; ", afToActDef(globalTypeActs(part, gt)))>;";

// By default, this is supposed to be an action def, but setting typ=false makes the list usable in block or allow.
list[str] afToActDef(Af af) = afToActDef(true, af);

// We focus on the shape of Af as generated by globalTypeActs and globalTypeGacts.
list[str] afToActDef(bool useTyp, ffAf()) = [];
list[str] afToActDef(bool useTyp, actionAf(str act)) = [act];
list[str] afToActDef(bool useTyp, union(list[Af] forms)) {
    list[str] res = [];
    for (Af form <- forms) {
        res = res + afToActDef(useTyp, form);
    }
    return res;
}
list[str] afToActDef(bool useTyp, existsAf(str typ, _, Af af)) {
    str res = "<split("(", afToActDef(useTyp, af)[0])[0]>";
    if (useTyp) {
        res = "<res> : <typ>";
    }
    return [res];
}

str recProcToMcrl(RecProc recProc, str part) {
    str res = "proc P_<part> = <procToMcrl(part, recProc.proc)>;";
    for (str var <- recProc.recs) {
        res = res + "\nproc P_<part>_<var> = <procToMcrl(part, recProc.recs[var])>;";        
    }
    return res;
}

str procToMcrl(_, action(str act)) = act;
str procToMcrl(str part, recCallP(str var)) = "P_<part>_<var>";
str procToMcrl(str part, seq(Proc pre, Proc suf)) = "<procToMcrl(part, pre)> . <procToMcrl(part, suf)>";
str procToMcrl(str part, nd(list[Proc] procs)) {
    res = "(<procToMcrl(part, procs[0])>";
    for (int i <- [1 .. size(procs)]) {
        res = res + " + <procToMcrl(part, procs[i])>";
    }
    return "<res>)";
}
str procToMcrl(str part, ndData(str typ, str var, Proc proc)) = "sum <var> : <typ> . <procToMcrl(part, proc)>";